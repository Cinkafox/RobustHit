using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace Content.SourceGenerator;

[Generator]
public class StateMessageHandlerMultiGenerator : IIncrementalGenerator
{
    private static readonly string MethodStateHandlerGenerateAttribute =
        "Content.Shared.SourceGen.MethodStateHandlerGenerateAttribute";
    private static readonly string AutoStateHandlerAttribute =
        "Content.Shared.SourceGen.AutoStateHandlerAttribute";
    
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var provider = context.SyntaxProvider
            .CreateSyntaxProvider(
                (s, _) => s is ClassDeclarationSyntax,
                (ctx, _) => SourceHelper.GetClassDeclarationForSourceGen(ctx, MethodStateHandlerGenerateAttribute))
            .Where(t => t.reportAttributeFound)
            .Select((t, _) => t.Item1);

        context.RegisterSourceOutput(context.CompilationProvider.Combine(provider.Collect()),
            (ctx, t) => GenerateCode(ctx, t.Left, t.Right));
    }
    
     private void GenerateCode(SourceProductionContext context, Compilation compilation,
        ImmutableArray<ClassDeclarationSyntax> classDeclarations)
    {
        foreach (var classDeclarationSyntax in classDeclarations)
        {
            var semanticModel = compilation.GetSemanticModel(classDeclarationSyntax.SyntaxTree);
            if (semanticModel.GetDeclaredSymbol(classDeclarationSyntax) is not INamedTypeSymbol symbol)
                continue;
            
            var namespaceName = symbol.ContainingNamespace.ToDisplayString();
            var className = classDeclarationSyntax.Identifier.Text;
            
            var methodsToGenerate = GetMethods(symbol);

            var propsGenerated = new StringBuilder();
            var constructorsGenerated = new StringBuilder();

            foreach (var method in methodsToGenerate)
            {
                propsGenerated.AppendLine($"[Robust.Shared.Serialization.Manager.Attributes.DataField] public Content.Shared.States.Handlers.IStateMessageHandler {method.Name}Handler = default!;");
                constructorsGenerated.AppendLine($"            {method.Name}Handler = new Content.Shared.States.Handlers.StateMessageHandler({method.Name});");
            }
            
            var code = $@"// <auto-generated/>
namespace {namespaceName};

partial class {className}
{{
    {propsGenerated}
    private void InitializeStateHandlers(){{
        {constructorsGenerated}
    }}
}}
            ";

            // Add the source code to the compilation.
            context.AddSource($"{className}_auto_handler_gen.g.cs", SourceText.From(code, Encoding.UTF8));
        }
    }

    private static IEnumerable<IMethodSymbol> GetMethods(INamedTypeSymbol classSymbol)
    {
        return classSymbol.GetMembers().OfType<IMethodSymbol>().Where(a =>
            SourceHelper.HasAttribute(a, AutoStateHandlerAttribute));
    }
}